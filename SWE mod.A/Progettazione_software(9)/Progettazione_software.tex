\input{../Templates/layout}
\input{../Templates/commands}
\begin{document}

\section{Progettazione software(9)}

Progettare prima di produrre. Si deve avere un approccio industriale con un metodo ingegneristico, ossia si deve perseguire la \textbf{correttezza per costruzione} e non la correttezza per correzione.

Bisogna cercare di ridurre al minimo lo sforzo della verifica, altrimenti pago un costo doppio. Per cercare di mitigare la verifica uso il principio di riduzione della complessità. Progettare per:
\begin{enumerate}
	\item Governare la complessità del prodotto;
	\item Organizzare e ripartire le responsabilità di realizzazione;
	\item Produrre in economia (efficienza);
	\item Garantire controllo di qualità (efficacia);
\end{enumerate}

L'approccio dell'analista è detto \textit{approccio investigativo}. Tutto non è necessariamente esplicito. Il lavoro del progettista è l'esatto opposto, deve riportare a sintesi i requisiti spezzettati e proporre una delle possibili soluzioni al problema, argomentando il valore di quella soluzione. L'analista ha fatto un buon lavoro se i requisiti sono tutti \textbf{tracciabili} e \textbf{verificabili}.\\
Dijkstra afferma che per soddisfare i nostri bisogni:

\begin{itemize}

	\item \textbf{Stabilire le proprietà} di quella cosa in virtù delle quali soddisfo le proprietà attese e i bisogni. Questo è il compito dell'analista.
	\item \textbf{Fare quella cosa} in modo tale che le proprietà attese ci siano. E' quello che fa il progettista.

\end{itemize}

Uno dei compiti che aiuta il progettista è \textbf{fissare un'architettura}, cioè il modo in cui affrontiamo la struttura della soluzione.

Un progettista che lavora strettamente sul progetto fa \textbf{scelte tattiche} sul breve periodo, mentre un architetto ha \textbf{governance}, ha una visione sul lungo periodo. Vogliamo che il progettista si avvicini il più possibile all'architetto. Architettura sw comprende:

\begin{itemize}

	\item Una collezione di software e componenti di sistema, regole e vincoli;
	\item Una collezione di bisogni per gli stakeholders;
	\item Una motivazione per cui la prima collezione soddisfa tutti i bisogni della seconda.
\end{itemize}


Prima di avere componenti, connessioni e vincoli bisogna avere l'idea di come sono le parti, dobbiamo avere un principio costruttivo. Sapere che forma devono avere le parti per ottenere le caratteristiche che mi servono. Esponendo un'interfaccia mostro che cosa offro. Ogni architettura ha uno \textbf{stile} architetturale riconoscibile. Secondo ISO/IEC/IEEE 42010-2011:

\begin{itemize}

	\item L'architettura è un modo per distinguere le parti (\textit{divide});
	\item Quelle parti sono organizzate (\textit{impera});
	\item Per poter avere un'organizzazione di parti bisogna avere delle interfacce che facilitino l'organizzazione;
	\item Paradigma di composizione, il criterio con cui metto insieme queste parti, regole, criteri, vincoli che hanno impatto sulla manutenzione futura.

\end{itemize}

Assunto di aver capito  questo, cerchiamo quali sono le qualità da perseguire in un'architettura:

\begin{itemize}

	\item \textbf{Sufficienza:} soddisfa tutti i requisiti;
	\item \textbf{Comprensibilità:} comprensibile hai portatori d'interesse;
	\item \textbf{Modularità:} fatta di parti facilmente riproducibili e distinte;
	\item \textbf{Robustezza:} sopporta ingressi diversi \textit{(giusti, sbagliati, tanti pochi)};
	\item \textbf{Flessibilità:} permette modifiche a costo contenuto al variare dei requisiti;
	\item \textbf{Riusabilità:} architettura riadattabile a molti altri sistemi, sia nell'insieme che nelle parti;
	\item \textbf{Efficienza:} nel tempo, nello spazio, nelle comunicazioni. Consumare il meno possibile.
	\item \textbf{Affidabilità:} nessun \textit{effetto sorpresa}, riesco a fare ciò che è atteso;
	\item \textbf{Disponibilità:} necessita di poco o nullo tempo di manutenzione \textit{fuori linea};
	\item \textbf{Sicurezza rispetto a intrusioni};
	\item \textbf{Sicurezza rispetto al funzionamento};
	\item \textbf{Semplicità:} ogni parte contiene il necessario e niente di \textit{superfluo}, utilizzo il principio di \textit{Occam}, elimino tutto quello che è superfluo;
	\item \textbf{Incapsulamento:} (information hiding), nascondo il dettaglio, mostro solo il necessario, in oltre i cresce anche la manutenibilità. Le componenti sono \textit{Black box}, i clienti conoscono solamente l'interfaccia mentre la loro specifica nasconde gli algoritmi e le strutture dati usati all'interno;
	\item \textbf{Coesione:} le parti che stanno insieme hanno gli stessi obiettivi, questa aiuta sia a decomporre che a mettere un limite inferiore alla decomposizione. Maggiore manutenibilità e riusabilità, minore interdipendenza, maggiore comprensione dell'architettura;
	\item \textbf{Basso accoppiamento:} una modifica ha impatto minimo con gli altri. Le modifiche locali non devono avere effetto sul globale, questo è misurabile ed e composto da due valori, utilità e bisogno. Per calcolarlo si usa la metrica fan-in, fan-out, la prima da massimizzare e la seconda da minimizzare.

\end{itemize}

All'inizio della progettazione devo avere sicuramente uno stile architetturale che può essere o \textbf{top-down} (decompone i problemi) o \textbf{bottom-up} (compone le soluzioni). L'approccio normalmente utilizzato è un \textbf{compromesso} fra queste due tecniche, \textbf{meet-in-the-middle}, un approccio intermedio.

Un \textbf{pattern} lo possiamo intendere come soluzioni fattorizzate per problemi ricorrenti.

I  pattern architetturali possono essere molti:

\begin{itemize}
	\item Architettura a livelli (\textit{Three-tier}) che comprende lo stato della presentazione, quello della logica operativa, e quello dell'organizzazione dei dati;
	\item Architettura produttore-consumatore;
	\item Architettura cliente-servente, ci sono due sottovarianti, con \textit{fat client} e con \textit{thin client};
	\item Architettura \textit{peer-to-peer}, interconnessione di scambio senza server di mezzo.
	\item Architettura di relazione, MVC, il \textbf{Model} incorpora il modello dei dati e le operazioni su di essi, la \textbf{View} incorpora la logica di presentazione, riceve in input e mostra in output l'esito delle azioni svolte dal controller sul model, \textbf{Controller} incorpora la logica di controllo del sistema;
\end{itemize}

E' importante capire che l'architettura dev'essere valutata per la sua \textbf{qualità}. Cercheremo metodi utili e ambienti di progettazione che questi metodi importano. Questo perchè perseguiamo \textit{qualità by construction}. Vogliamo che la \textbf{baseline} sia pulita e quindi bisogna verificare che l'architettura lo sia. La progettazione la distingueremo in due fasi (lassi di tempo contigui e continui):

\begin{itemize}

	\item una di \textbf{alto livello} in cui fissiamo l'architettura e i pattern;
	\item una di \textbf{dettaglio} in cui riempiamo i buchi per agevolare il lavoro del programmatore. Definizione delle unità realizzative \textbf{moduli}.In questa fase in oltre si assegnano le attività ai componenti, si produce la documentazione necessaria perchè la programmazione possa procedere in modo più disciplinato e certo possibile.

\end{itemize}

\textbf{Stati di processo} per SEMAT:

\begin{itemize}

	\item \textbf{Architecture selected:} dobbiamo scegliere l'architettura e dobbiamo spiegare perché essa è adatta al sistema. Selezione delle tecnologie necessarie, posso quindi fare stime di costo sensate. Decisione su \textbf{buy}, \textbf{build}, \textbf{make}. In questo stadio di avanzamento non c'è nemmeno una linea di codice, niente di realizzato;
	\item \textbf{Demonstrable:} dimostrazione delle principali caratteristiche del sistema agli stakeholder. Decisioni su interfacce e configurazioni di sistema. Ho fatto e ho completato la progettazione ad alto livello ed eventualmente ho dei prototipi, ma non ho ancora implementato nulla;
	\item \textbf{Usable:} il sistema è usabile e ha le caratteristiche desiderate. Non è completamente finito, ho ancora difetti, ma essi sono accettabili. Quindi possiamo \textit{sperare} di iniziare a fare la revisione di collaudo;
	\item \textbf{Ready:} il prodotto è così maturo che posso iniziare a scrivere il \textit{manuale utente}, la documentazione per l'utente è pronta, gli stakeholder hanno accettato il prodotto e vogliono che diventi operativo.
\end{itemize}

\end{document}